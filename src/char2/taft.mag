/* 
*  Created by PAB on 5/31/2023
*
*  Functions to carry out the "linear lifting" case in [BKW]
*/

// eventually import these when the intrinsics are set

StarTrace := function (A, z) 
return z + z @ A`Star; 
end function;

StarNorm := function (A, z) 
return (z @ A`Star) * z; 
end function;

StarDelta := function (A, z) 
return StarTrace (A, z) + StarNorm (A, z); 
end function;

/*
  This function is for internal use. Typically, a Wedderburn 
  complement S to the radical J(R) of a *-algebra R is not 
  invariant under the involution. However, the decomposition 
  R = J + S imposes on S an involution by projection.

  This variant of the intrinsic WedderburnDecomposition 
  equips the complement with this involution.
*/

       __MWD_dot := function (D, S, MatD, s) 
            e := Dimension (S);
            t := Generic (MatD)!(D!s @ D`Star);
            assert t in MatD;
            c := Coordinates (MatD, t);
       return &+ [ c[l] * S.l : l in [1..Ngens(S)] ];
       end function;

MyWedderburnDecomposition := function (D)
     assert IsStarAlgebra (D);
     J, S := WedderburnDecomposition (D);
     S_basis := Basis (S);
     S := sub < Generic (S) | S_basis >;     // ensure S is generated by a basis
     MS := KMatrixSpace (BaseRing (D), Degree (D), Degree (D));
     MatD := KMatrixSpaceWithBasis (
               [ MS!(S.l) : l in [1..Ngens(S)] ] cat 
               [ MS!Z : Z in Basis (J) ]
                                   );
     S`Star := hom < S -> S | s :-> __MWD_dot (D, S, MatD, s) >;
     J`Star := hom < J -> J | z :-> z @ D`Star >;
return J, S;
end function;

// Given data (D,J,Q,S) decide if we are in the "linear" case
       __MD_delta := function (D, S, s)
       return (s @ S`Star) @ D`Star - s;
       end function;

// temporary intrinsic
intrinsic MyDerivation (D::AlgMat, J::AlgMat, Q::AlgMat, S::AlgMat) -> AlgMatElt, BoolElt 
  { Temporary intrinsic for distinguishing linear and non-linear cases. }

     // form the matrix for the linear operator <delta> : S --> Q/QJ
     Qbar, pi := quo < Q | Q * J >;
     dQbar := Dimension (Qbar);
     dS := Dimension (S);   assert dS eq Ngens (S);
     MS := KMatrixSpace (BaseRing (D), dS, dQbar);
     DELTA := MS!Matrix ([ __MD_delta (D, S, S.j) @ pi : j in [1..dS] ]);

     // build the space of inner derivations
     igens := [ ];   
     INN_Q := sub < MS | 0 >;
     I := [ ];
     for l in [1..dQbar] do 
          z := Qbar.l @@ pi;
          iz := MS!Matrix ([ (S.j * z + z * S.j) @ pi : j in [1..dS] ]);
          if not iz in INN_Q then   // bit of a hack to ensure a basis
               Append (~igens, iz);
               Append (~I, l);
               INN_Q := sub < MS | igens >;
          end if;
     end for;
     INN_Q := KMatrixSpaceWithBasis (igens);    
     assert (DELTA in INN_Q);  // check that <delta> is an inner derivation
     
     // build the w in Q corresponding DELTA
     c := Coordinates (INN_Q, DELTA);
     assert DELTA eq &+ [ c[l] * igens[l] : l in [1..#igens] ];
     w := Q!(&+ [ c[l] * (Qbar.(I[l]) @@ pi) : l in [1..#igens] ]);

     // finally see if we're in the generic or exotic case
     generic := (StarTrace (D, w) eq 0);

return w, generic;
end intrinsic;

/*
Here is the input data to be modified:

      D = subalgebra of given R with D^# = R^#
      J = J(D), the Jacobson radical of D
      Q = *-ideal of D contained in J such that S/Q is *-invariant in D/Q
          ( (s^.)^* - s lives in Q )
      S = semisimple ring complement to J in D
          (ensure that the generators of S are always a basis)
          (S gets an involution from the decomp D = J + S)
      U = unipotent group containing 1+Q such that 
          U / (1+Q) is isomorphic (1 + J/Q)^#
          (this is the same group U from RadicalUnitarians intrinsic)
          NOTE: need to make sure the input U has "GF(2)-gens" see RadUnit

The following procedure updates these data, but doing so in a way 
that the pair   < dim(D) , dim(Q) >   gets smaller, lexicographically
*/

procedure LinearLift (~D, ~J, ~Q, ~S, ~U : RANDOM := true) 

     d := Degree (D);
     K := BaseRing (D); 
     k := Degree (K);
     rho := PrimitiveElement (K);
     one := Identity (D);

     QJ := Q * J;  

          // lifted from MyDerivation above ... probably should consolidate at some point

          // form the matrix for the linear operator <delta> : S --> Q/QJ
          Qbar, pi := quo < Q | Q * J >;
          dQbar := Dimension (Qbar);
          dS := Dimension (S);   assert dS eq Ngens (S);
          MS := KMatrixSpace (BaseRing (D), dS, dQbar);
          DELTA := MS!Matrix ([ __MD_delta (D, S, S.j) @ pi : j in [1..dS] ]);

              // build the space of inner derivations
              igens := [ ];   
              INN_Q := sub < MS | 0 >;
              I := [ ];
              for l in [1..dQbar] do 
                   z := Qbar.l @@ pi;
                   iz := MS!Matrix ([ (S.j * z + z * S.j) @ pi : j in [1..dS] ]);
                   if not iz in INN_Q then   // bit of a hack to ensure a basis
                        Append (~igens, iz);
                        Append (~I, l);
                        INN_Q := sub < MS | igens >;
                   end if;
              end for;
              INN_Q := KMatrixSpaceWithBasis (igens);    
              assert (DELTA in INN_Q);  // check that <delta> is an inner derivation
     
          // build the w in Q corresponding DELTA
          c := Coordinates (INN_Q, DELTA);
          assert DELTA eq &+ [ c[l] * igens[l] : l in [1..#igens] ];
          w := Q!(&+ [ c[l] * (Qbar.(I[l]) @@ pi) : l in [1..#igens] ]);

          // catch the non-linear case --- right now we'll just get an assertion failure
          assert (StarTrace (D, w) eq 0);
 
    // build matrix representing GF(2)-linear map <mu> : G / G^2 * [G,G] ---> K / U
    Q2, f := WriteOverSmallerField (Q, GF(2));
    QJ2 := sub < Q2 | [ QJ.i @ f : i in [1..Ngens (QJ)] ] >; 
    QmodQJ, pi := quo < Q2 | QJ2 >;

    // NOTE: <mu>(u) = <Delta>(u-1) is what Martin is calling \bar{n} 
    // so, we just need to see if w is in the image of this map
    M := Matrix ([ (StarDelta (D, D!(U.i) - one) @ f) @ pi : i in [1..Ngens (U)] ]);
//    IMAGE := VectorSpaceWithBasis ([ Vector (M[i]) : i in [1..Nrows (M)] ]);
    twist := (w @ f) @ pi in RowSpace (M);

    if twist then     // use u to twist S to a *-invariant complement mod QJ

vprint Isometry, 1 : "[LinearLift] twisting the complement";  

              // D stays the same 
              // J stays the same
              Q := QJ;

// find an element u of U that maps to this vector
/*
c := Coordinates (IMAGE, (w @ f) @ pi);
u := &* [ U.i^Integers ()!(c[i]) : i in [1..Ngens (U)] ];
(u @ D`Star) * u - one - w in QJ;
*/
// fix this type of computation once and for all

// update S by twisting
assert exists (u){ x : x in U | x @ D`Star * x - one - w in QJ };
T := sub < Generic (S) | [ u^-1 * S.i * u : i in [1..Ngens (S)] ] >;
T`Star := hom < T -> T | t :-> u^-1 * ( (u * t * u^-1) @ S`Star ) * u >;
S := T; 

              // update U
              null := Nullspace (M);
              ker := sub < GL (d, K) | [
                  &* [ U.i^Integers ()!(n[i]) : i in [1..Ngens (U)] ] : n in Basis (null)
                                       ]
                         >;
              // compute the derived subgroup of G: randomized or deterministic
              if RANDOM then
                   DU := DerivedGroupMonteCarlo (U);
              else 
                   DU := LMGDerivedGroup (U);
              end if;  
              U := sub < GL (d, K) | ker , DU , [ U.i^2 : i in [1..Ngens (U)] ] >;
                   vprint Isometry, 1 : "[LinearLift] order of U =", #U;

    else              // swap D for an algebra fixing w in linear action 

vprint Isometry, 1 : "[LinearLift] not implemented yet";
Q := sub < Generic (Q) | Q!0 >;

    end if;

end procedure;