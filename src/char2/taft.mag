/* 
  Created by PAB on 5/31/2023

  Functions to carry out Section 3 of [BKW]
  
  Data:
      D = subalgebra of given R with D^# = R^#
      J = J(D), the Jacobson radical of D
      S = semisimple ring complement to J in D
          (ensure that the generators of S are always a basis)
          (S has an involution . corresponding to decomp D = J + S)
      Q = *-ideal of D contained in J such that S/Q is *-invariant in D/Q
          ( (s^.)^* - s lives in Q )
*/

import "util.mag" : StarTrace;


       // adaptation of function to induce an involution on the complement
       __MWD_dot := function (D, S, MatD, s) 
            e := Dimension (S);
            t := Generic (MatD)!(D!s @ D`Star);
            assert t in MatD;
            c := Coordinates (MatD, t);
       return &+ [ c[l] * S.l : l in [1..Ngens(S)] ];
       end function;

MyWedderburnDecomposition := function (D)
     J, S := WedderburnDecomposition (D);
     S_basis := Basis (S);
     S := sub < Generic (S) | S_basis >;     // ensure S is generated by a basis
     MS := KMatrixSpace (BaseRing (D), Degree (D), Degree (D));
     MatD := KMatrixSpaceWithBasis (
               [ MS!(S.l) : l in [1..Ngens(S)] ] cat 
               [ MS!Z : Z in Basis (J) ]
                                   );
     S`Star := hom < S -> S | s :-> __MWD_dot (D, S, MatD, s) >;
     J`Star := hom < J -> J | z :-> z @ D`Star >;
return J, S;
end function;

// Given data (D,J,Q,S) decide if we are in the "linear" case
       __MD_delta := function (D, S, s)
       return (s @ S`Star) @ D`Star - s;
       end function;

// temporary intrinsic
intrinsic MyDerivation (D::AlgMat, J::AlgMat, Q::AlgMat, S::AlgMat) -> AlgMatElt, BoolElt 
  { Temporary intrinsic for distinguishing linear and non-linear cases. }

     // form the matrix for the linear operator <delta> : S --> Q/QJ
     Qbar, pi := quo < Q | Q * J >;
     dQbar := Dimension (Qbar);
     dS := Dimension (S);   assert dS eq Ngens (S);
     MS := KMatrixSpace (BaseRing (D), dS, dQbar);
     DELTA := MS!Matrix ([ __MD_delta (D, S, S.j) @ pi : j in [1..dS] ]);

     // build the space of inner derivations
     igens := [ ];   
     INN_Q := sub < MS | 0 >;
     I := [ ];
     for l in [1..dQbar] do 
          z := Qbar.l @@ pi;
          iz := MS!Matrix ([ (S.j * z + z * S.j) @ pi : j in [1..dS] ]);
          if not iz in INN_Q then   // bit of a hack to ensure a basis
               Append (~igens, iz);
               Append (~I, l);
               INN_Q := sub < MS | igens >;
          end if;
     end for;
     INN_Q := KMatrixSpaceWithBasis (igens);    
     assert (DELTA in INN_Q);  // check that <delta> is an inner derivation
     
     // build the w in Q corresponding DELTA
     c := Coordinates (INN_Q, DELTA);
     assert DELTA eq &+ [ c[l] * igens[l] : l in [1..#igens] ];
     w := Q!(&+ [ c[l] * (Qbar.(I[l]) @@ pi) : l in [1..#igens] ]);

     // finally see if we're in the generic or exotic case
     generic := (StarTrace (D, w) eq 0);

return w, generic;
end intrinsic;