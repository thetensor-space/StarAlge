/* 
*  Created by PAB on 5/31/2023
*
*  Functions to carry out the "linear lifting" case in [BKW]
*/

// eventually import these when the intrinsics are set

StarTrace := function (A, z) 
return z + z @ A`Star; 
end function;

StarNorm := function (A, z) 
return (z @ A`Star) * z; 
end function;

StarDelta := function (A, z) 
return StarTrace (A, z) + StarNorm (A, z); 
end function;

/*
  This function is for internal use. Typically, a Wedderburn 
  complement S to the radical J(R) of a *-algebra R is not 
  invariant under the involution. However, the decomposition 
  R = J + S imposes on S an involution by projection.

  This variant of the intrinsic WedderburnDecomposition 
  equips the complement with this involution.
*/

       __MWD_dot := function (D, S, MatD, s) 
            e := Dimension (S);
            t := Generic (MatD)!(D!s @ D`Star);
            assert t in MatD;
            c := Coordinates (MatD, t);
       return &+ [ c[l] * S.l : l in [1..Ngens(S)] ];
       end function;

MyWedderburnDecomposition := function (D)
     assert IsStarAlgebra (D);
     J, S := WedderburnDecomposition (D);
     S_basis := Basis (S);
     S := sub < Generic (S) | S_basis >;     // ensure S is generated by a basis
     MS := KMatrixSpace (BaseRing (D), Degree (D), Degree (D));
     MatD := KMatrixSpaceWithBasis (
               [ MS!(S.l) : l in [1..Ngens(S)] ] cat 
               [ MS!Z : Z in Basis (J) ]
                                   );
     S`Star := hom < S -> S | s :-> __MWD_dot (D, S, MatD, s) >;
     J`Star := hom < J -> J | z :-> z @ D`Star >;
return J, S;
end function;


GetDerivation := function (D, J, Q, S) 

     // form the matrix for the linear operator <delta> : S --> Q/QJ
     Qbar, pi := quo < Q | Q * J >;
     dQbar := Dimension (Qbar);
     dS := Dimension (S);   assert dS eq Ngens (S);
     MS := KMatrixSpace (BaseRing (D), dS, dQbar);
     assert forall { j : j in [1..dS] | (S.j @ S`Star) @ D`Star + S.j in Q };
     DELTA := MS!Matrix ([ ((S.j @ S`Star) @ D`Star + S.j) @ pi : j in [1..dS] ]);

     // build the space of inner derivations
     igens := [ ];   
     INN_Q := sub < MS | 0 >;
     I := [ ];
     for l in [1..dQbar] do 
          z := Qbar.l @@ pi;
          iz := MS!Matrix ([ (S.j * z + z * S.j) @ pi : j in [1..dS] ]);
          if not iz in INN_Q then   // bit of a hack to ensure a basis
               Append (~igens, iz);
               Append (~I, l);
               INN_Q := sub < MS | igens >;
          end if;
     end for;
     INN_Q := KMatrixSpaceWithBasis (igens);    
     assert (DELTA in INN_Q);  // check that <delta> is an inner derivation
     
     // build the w in Q corresponding DELTA
     c := Coordinates (INN_Q, DELTA);
     assert DELTA eq &+ [ c[l] * igens[l] : l in [1..#igens] ];
     w := Q!(&+ [ c[l] * (Qbar.(I[l]) @@ pi) : l in [1..#igens] ]);

     // finally see if we're in the generic or exotic case
     LINEAR := (StarTrace (D, w) eq 0);

return w, LINEAR;
end function;

GetAnnihilator := function (S, w)

return A;
end function;


/*
Here is the input data to be modified:

      D = subalgebra of given R with D^# = R^#

      J = J(D), the Jacobson radical of D

      Q = *-ideal of D contained in J such that S/Q is *-invariant in D/Q
          ( (s^.)^* - s lives in Q )

      S = semisimple ring complement to J in D
          (ensure that the generators of S are always a basis)
          (S gets an involution from the decomp D = J + S)

      U = unipotent group containing 1+Q such that 
          U / (1+Q) is isomorphic (1 + J/Q)^#
          (this is the same group U from RadicalUnitarians intrinsic)

The following procedure updates these data, but doing so in a way 
that the pair   < dim(D) , dim(Q) >   gets smaller, lexicographically
*/

procedure LinearLift (~D, ~J, ~Q, ~S, ~U : RANDOM := true) 

     d := Degree (D);
     K := BaseRing (D); 
     k := Degree (K);
     rho := PrimitiveElement (K);
     one := Identity (D);         

     // get the inner derivation and check we're in the Linear Case
     w, LINEAR := GetDerivation (D, J, Q, S);
     vprint Isometry, 2 : "[LinearLift] inner derivation w =", w; 
     vprint Isometry, 2 : "[LinearLift] tr(w) =", w + w @ D`Star; 

    if not LINEAR then  
    // eventually this procedure will pass w as input and it will
    // have been checked beforehand that we are in the linear case
         vprint Isometry, 1 : "[LinearLift] not the linear case";
         Q := sub < Generic (Q) | Q!0 >;
    else

    // this section of code is lifted from RadicalUnitarians
    // build matrix representing map <mu> : G / G^2 * [G,G] ---> K / U
    QJ := Q * J;
    Q2, f := WriteOverSmallerField (Q, GF(2));
    QJ2 := sub < Q2 | [ QJ.i @ f : i in [1..Ngens (QJ)] ] >; 
    QmodQJ, pi := quo < Q2 | QJ2 >;

    // check whether w is in the image of <mu> : U --> QmodQJ
    gen_images := [ (StarDelta (D, D!(U.i) - one) @ f) @ pi : i in [1..Ngens (U)] ];
    M := Matrix (gen_images);
    TWIST := (w @ f) @ pi in sub < QmodQJ | gen_images >;

    if TWIST then     // use u to twist S to a *-invariant complement mod QJ

         vprint Isometry, 1 : "[LinearLift] twisting the complement";  

              // D stays the same 
              // J stays the same

              // update Q
              Q := QJ;

              // update S
              gen_vecs := [Vector (gen_images[i]) : i in [1..#gen_images]];
              c := LinearCombination (gen_vecs, Vector ((w @ f) @ pi));
              u := &* [ U.i^Integers ()!(c[i]) : i in [1..Ngens (U)] ];
//assert exists (u){ x : x in U | x @ D`Star * x - one - w in QJ };  --- brute force alternative
              assert (u @ D`Star) * u - one - w in QJ;
              vprint Isometry, 2 : "[LinearLift] twisting element is u =", u;
              T := sub < Generic (S) | [ u^-1 * S.i * u : i in [1..Ngens (S)] ] >;
              T`Star := hom < T -> T | t :-> u^-1 * ( (u * t * u^-1) @ S`Star ) * u >;
              S := T;
              assert forall { s : s in Generators (S) | s + (s @ S`Star) @ D`Star in QJ };

              // update U
              null := Nullspace (M);
              ker := sub < GL (d, K) | [
                  &* [ U.i^Integers ()!(n[i]) : i in [1..Ngens (U)] ] : n in Basis (null)
                                       ]
                         >;
              if RANDOM then     // use randomized algorithm to compute the derived subgroup
                   DU := DerivedGroupMonteCarlo (U);
              else               // use the defaul from the Large Matrix Group library
                   DU := LMGDerivedGroup (U);
              end if;  
              U := sub < GL (d, K) | ker , DU , [ U.i^2 : i in [1..Ngens (U)] ] >;
                   vprint Isometry, 1 : "[LinearLift] order of U =", LMGOrder (U);

    else              // swap D for an algebra fixing w in linear action 

         vprint Isometry, 1 : "[LinearLift] reduce semisimple part (not implemented yet)";
         // just set Q to 0 for now
         Q := sub < Generic (Q) | Q!0 >;

    end if;

end if;

end procedure;